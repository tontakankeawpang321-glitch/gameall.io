<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wizard Chess 3D - Model Loading Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- ‡πÄ‡∏û‡∏¥‡πà‡∏° GLTFLoader ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå .glb -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', 'Kanit', Tahoma, Geneva, Verdana, sans-serif; background: #e5e7eb; touch-action: none; }
        
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .status-panel {
            background: rgba(255, 255, 255, 0.92);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid #d1d5db;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: auto;
            max-width: fit-content;
        }

        #turn-indicator { font-size: 18px; font-weight: bold; margin-bottom: 2px; color: #2563eb; }
        #info { font-size: 12px; color: #4b5563; line-height: 1.4; }
        #voice-status { margin-top: 6px; font-size: 12px; font-style: italic; color: #059669; font-weight: bold; }
        
        #voice-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 14px 20px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 15px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.5);
            transition: all 0.3s;
            pointer-events: auto;
            z-index: 100;
        }

        #loading-screen {
            position: absolute;
            inset: 0;
            background: #f3f4f6;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-weight: bold;
            color: #1f2937;
        }

        @media (max-width: 600px) {
            #voice-btn {
                bottom: 20px;
                right: 50%;
                transform: translateX(50%);
                width: 80%;
                text-align: center;
            }
            #turn-indicator { font-size: 16px; }
            .status-panel { padding: 10px; }
        }

        #voice-btn:hover { background: #2563eb; }
        #voice-btn.listening { background: #dc2626; animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(220, 38, 38, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(17, 24, 39, 0.9);
            color: #fff;
            padding: 12px 20px;
            border-radius: 25px;
            display: none;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            font-weight: 500;
            z-index: 1000;
            text-align: center;
            pointer-events: none;
        }
        
        canvas { display: block; }
    </style>
</head>
<body>

<div id="loading-screen">
    <div style="font-size: 24px; margin-bottom: 10px;">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡∏°‡∏£‡∏†‡∏π‡∏°‡∏¥‡πÄ‡∏ß‡∏ó‡∏°‡∏ô‡∏ï‡∏£‡πå...</div>
    <div id="loading-progress" style="font-size: 14px; color: #6b7280;">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• 3 ‡∏°‡∏¥‡∏ï‡∏¥</div>
</div>

<div id="ui-layer">
    <div class="status-panel">
        <div id="turn-indicator">‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á: ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô</div>
        <div id="info">
            ‡πÅ‡∏ï‡∏∞‡∏´‡∏°‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏¥‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏±‡πà‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á:<br>
            "‡∏°‡πâ‡∏≤‡∏Å‡∏¥‡∏ô‡πÄ‡∏£‡∏∑‡∏≠", "‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏Å‡∏¥‡∏ô‡∏°‡πâ‡∏≤"
        </div>
        <div id="voice-status"></div>
    </div>
</div>

<button id="voice-btn" onclick="toggleVoice()">üé§ ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡∏Ñ‡πå‡∏™‡∏±‡πà‡∏á‡∏Å‡∏≤‡∏£</button>
<div id="message-box"></div>

<script>
/** * Wizard Chess 3D - GLB Loader Integration
 */

let scene, camera, renderer, raycaster, mouse;
let board = [];
let pieces = [];
let selectedPiece = null;
let currentTurn = 'white'; 
let moveHighlights = [];
let modelTemplates = {}; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß

const PIECES = {
    EMPTY: 0,
    PAWN: 1, ROOK: 2, KNIGHT: 3, BISHOP: 4, QUEEN: 5, KING: 6
};

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Path ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏• .glb (‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç URL ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ)
const MODEL_PATHS = {
    [PIECES.PAWN]: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/models/gltf/RobotExpressive/RobotExpressive.glb', // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á URL
    [PIECES.ROOK]: '',
    [PIECES.KNIGHT]: '',
    [PIECES.BISHOP]: '',
    [PIECES.QUEEN]: '',
    [PIECES.KING]: ''
};

const THAI_PIECES = {
    '‡πÄ‡∏ö‡∏µ‡πâ‡∏¢': PIECES.PAWN,
    '‡πÄ‡∏£‡∏∑‡∏≠': PIECES.ROOK,
    '‡∏°‡πâ‡∏≤': PIECES.KNIGHT,
    '‡∏ö‡∏¥‡∏ä‡∏≠‡∏õ': PIECES.BISHOP,
    '‡πÇ‡∏Ñ‡∏ô': PIECES.BISHOP,
    '‡∏Ñ‡∏ß‡∏µ‡∏ô': PIECES.QUEEN,
    '‡πÄ‡∏°‡πá‡∏î': PIECES.QUEEN,
    '‡∏Ç‡∏∏‡∏ô': PIECES.KING,
    '‡∏Ñ‡∏¥‡∏á': PIECES.KING
};

let gameState = [
    [-2, -3, -4, -5, -6, -4, -3, -2],
    [-1, -1, -1, -1, -1, -1, -1, -1],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 1, 1],
    [2, 3, 4, 5, 6, 4, 3, 2]
];

let recognition;
let isListening = false;

window.onload = async function() {
    init();
    createBoard();
    await loadAllModels(); // ‡∏£‡∏≠‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô
    createPieces();
    initSpeech();
    
    // ‡∏ã‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÇ‡∏´‡∏•‡∏î
    document.getElementById('loading-screen').style.display = 'none';
    animate();
};

async function loadAllModels() {
    const loader = new THREE.GLTFLoader();
    const loadPromises = Object.entries(MODEL_PATHS).map(([type, url]) => {
        if (!url) return Promise.resolve(null);
        
        return new Promise((resolve) => {
            loader.load(url, 
                (gltf) => {
                    modelTemplates[type] = gltf.scene;
                    resolve(true);
                },
                undefined,
                (error) => {
                    console.warn(`Failed to load model for type ${type}:`, error);
                    resolve(false);
                }
            );
        });
    });

    await Promise.all(loadPromises);
}

function initSpeech() {
    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (window.SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.lang = 'th-TH';
        recognition.interimResults = false;
        
        recognition.onresult = (event) => {
            const command = event.results[0][0].transcript;
            document.getElementById('voice-status').innerText = `‡∏™‡∏±‡πà‡∏á‡∏ß‡πà‡∏≤: "${command}"`;
            processVoiceCommand(command.trim());
        };

        recognition.onend = () => { if (isListening) recognition.start(); };
        recognition.onerror = (event) => { console.error('Speech error:', event.error); };
    } else {
        document.getElementById('voice-btn').style.display = 'none';
    }
}

function toggleVoice() {
    if (!recognition) return;
    const btn = document.getElementById('voice-btn');
    if (!isListening) {
        recognition.start();
        isListening = true;
        btn.innerText = "üõë ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ü‡∏±‡∏á...";
        btn.classList.add('listening');
    } else {
        recognition.stop();
        isListening = false;
        btn.innerText = "üé§ ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡∏Ñ‡πå‡∏™‡∏±‡πà‡∏á‡∏Å‡∏≤‡∏£";
        btn.classList.remove('listening');
        document.getElementById('voice-status').innerText = "";
    }
}

function processVoiceCommand(text) {
    if (!text.includes('‡∏Å‡∏¥‡∏ô')) return;
    const parts = text.split('‡∏Å‡∏¥‡∏ô');
    if (parts.length < 2) return;

    const attackerName = parts[0].trim();
    const victimName = parts[1].trim();

    const attackerType = THAI_PIECES[Object.keys(THAI_PIECES).find(k => attackerName.includes(k))];
    const victimType = THAI_PIECES[Object.keys(THAI_PIECES).find(k => victimName.includes(k))];

    if (!attackerType || !victimType) {
        showMessage("‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏≤‡∏Å‡∏Ñ‡∏£‡∏±‡∏ö");
        return;
    }

    let foundMove = null;
    const myPieces = pieces.filter(p => p.color === currentTurn && p.type === attackerType);
    
    for (const p of myPieces) {
        const potentialVictims = pieces.filter(v => v.color !== currentTurn && v.type === victimType);
        for (const v of potentialVictims) {
            if (isValidMove(p, v.row, v.col)) {
                foundMove = { attacker: p, targetRow: v.row, targetCol: v.col };
                break;
            }
        }
        if (foundMove) break;
    }

    if (foundMove) {
        movePiece(foundMove.attacker, foundMove.targetRow, foundMove.targetCol);
    } else {
        showMessage(`‡πÑ‡∏°‡πà‡∏û‡∏ö ${attackerName} ‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏¥‡∏ô ${victimName} ‡πÑ‡∏î‡πâ`);
    }
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xd1d5db);
    scene.fog = new THREE.Fog(0xd1d5db, 10, 50);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    adjustCamera();

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.75); 
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
    mainLight.position.set(5, 15, 5);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 1024;
    mainLight.shadow.mapSize.height = 1024;
    scene.add(mainLight);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    window.addEventListener('mousedown', (e) => onPointerDown(e.clientX, e.clientY), false);
    window.addEventListener('touchstart', (e) => {
        if(e.touches.length > 0) onPointerDown(e.touches[0].clientX, e.touches[0].clientY);
    }, false);
    window.addEventListener('resize', onWindowResize, false);
}

function adjustCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    if (aspect < 1) {
        camera.fov = 65; 
        camera.position.set(0, 14, 6);
    } else {
        camera.fov = 45;
        camera.position.set(0, 13, 8);
    }
    camera.lookAt(0, -1.5, 0);
    camera.updateProjectionMatrix();
}

function createBoard() {
    const size = 1;
    for (let r = 0; r < 8; r++) {
        board[r] = [];
        for (let c = 0; c < 8; c++) {
            const isDark = (r + c) % 2 === 1;
            const geo = new THREE.BoxGeometry(size, 0.2, size);
            const mat = new THREE.MeshStandardMaterial({ 
                color: isDark ? 0x222222 : 0xffffff,
                roughness: 0.1,
                metalness: 0.1
            });
            const tile = new THREE.Mesh(geo, mat);
            tile.position.set(c - 3.5, 0, r - 3.5);
            tile.receiveShadow = true;
            tile.userData = { type: 'tile', row: r, col: c };
            scene.add(tile);
            board[r][c] = tile;
        }
    }
}

function createPieceMesh(type, color) {
    const absType = Math.abs(type);
    
    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÇ‡∏°‡πÄ‡∏î‡∏• .glb ‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ô‡∏±‡πâ‡∏ô
    if (modelTemplates[absType]) {
        const model = modelTemplates[absType].clone();
        
        // ‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡∏™‡∏µ (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á Mesh ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÇ‡∏°‡πÄ‡∏î‡∏•)
        model.traverse((node) => {
            if (node.isMesh) {
                node.material = node.material.clone();
                node.material.color.set(color === 'white' ? 0x2563eb : 0x1f2937);
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });

        // ‡∏õ‡∏£‡∏±‡∏ö Scale ‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡∏ä‡πà‡∏≠‡∏á (‡∏Ñ‡πà‡∏≤‡∏™‡∏°‡∏°‡∏ï‡∏¥ ‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏à‡∏£‡∏¥‡∏á)
        model.scale.set(0.4, 0.4, 0.4);
        return model;
    }

    // Fallback: ‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏ó‡∏£‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏°‡πÄ‡∏î‡∏•
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ 
        color: color === 'white' ? 0x2563eb : 0x1f2937,
        roughness: 0.2,
        metalness: 0.4
    });

    let body;
    if (absType === PIECES.PAWN) {
        body = new THREE.Mesh(new THREE.SphereGeometry(0.28, 20, 20), mat);
        body.position.y = 0.5;
    } else if (absType === PIECES.ROOK) {
        body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 0.8, 20), mat);
        body.position.y = 0.5;
    } else if (absType === PIECES.KNIGHT) {
        body = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.7, 0.45), mat);
        body.position.y = 0.45;
    } else if (absType === PIECES.BISHOP) {
        body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.35, 0.9, 20), mat);
        body.position.y = 0.55;
    } else if (absType === PIECES.QUEEN) {
        body = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.38, 1.1, 20), mat);
        const top = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.06, 12, 24), mat);
        top.rotation.x = Math.PI/2;
        top.position.y = 0.6;
        body.add(top);
        body.position.y = 0.6;
    } else if (absType === PIECES.KING) {
        body = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.4, 1.3, 20), mat);
        const top = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), mat);
        top.position.y = 0.7;
        body.add(top);
        body.position.y = 0.7;
    }
    
    group.add(body);
    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.42, 0.15, 24), mat);
    base.position.y = 0.075;
    group.add(base);
    
    group.traverse(n => { if(n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
    return group;group;
}

function createPieces() {
    pieces.forEach(p => scene.remove(p.mesh));
    pieces = [];

    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const val = gameState[r][c];
            if (val !== 0) {
                const color = val > 0 ? 'white' : 'black';
                const mesh = createPieceMesh(val, color);
                mesh.position.set(c - 3.5, 0, r - 3.5);
                scene.add(mesh);
                pieces.push({ mesh, row: r, col: c, color, type: Math.abs(val) });
            }
        }
    }
}

function onPointerDown(clientX, clientY) {
    mouse.x = (clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length > 0) {
        let object = intersects[0].object;
        while (object.parent && !object.userData.type && object.parent !== scene) object = object.parent;
        let clickedTile = null;
        if (object.userData.type === 'tile') {
            clickedTile = object.userData;
        } else {
            const piece = pieces.find(p => p.mesh === object || p.mesh.children.includes(object));
            if (piece) clickedTile = { row: piece.row, col: piece.col };
        }
        if (clickedTile) handleInteraction(clickedTile.row, clickedTile.col);
    }
}

function handleInteraction(r, c) {
    const pieceAtPos = pieces.find(p => p.row === r && p.col === c);
    if (selectedPiece) {
        if (isValidMove(selectedPiece, r, c)) {
            movePiece(selectedPiece, r, c);
            selectedPiece = null;
            clearHighlights();
        } else if (pieceAtPos && pieceAtPos.color === currentTurn) {
            selectPiece(pieceAtPos);
        } else {
            selectedPiece = null;
            clearHighlights();
        }
    } else if (pieceAtPos && pieceAtPos.color === currentTurn) {
        selectPiece(pieceAtPos);
    }
}

function selectPiece(piece) {
    clearHighlights();
    selectedPiece = piece;
    const geo = new THREE.RingGeometry(0.45, 0.52, 32);
    const mat = new THREE.MeshBasicMaterial({ color: 0xf59e0b, side: THREE.DoubleSide });
    const ring = new THREE.Mesh(geo, mat);
    ring.rotation.x = Math.PI / 2;
    ring.position.set(piece.col - 3.5, 0.15, piece.row - 3.5);
    scene.add(ring);
    moveHighlights.push(ring);
}

function clearHighlights() {
    moveHighlights.forEach(h => scene.remove(h));
    moveHighlights = [];
}

function isValidMove(piece, targetR, targetC) {
    if (piece.row === targetR && piece.col === targetC) return false;
    const dr = targetR - piece.row;
    const dc = targetC - piece.col;
    const targetPiece = pieces.find(p => p.row === targetR && p.col === targetC);
    if (targetPiece && targetPiece.color === piece.color) return false;

    switch(piece.type) {
        case PIECES.PAWN:
            const dir = piece.color === 'white' ? -1 : 1;
            if (dc === 0 && !targetPiece) {
                if (dr === dir) return true;
                if (dr === 2 * dir && ((piece.color === 'white' && piece.row === 6) || (piece.color === 'black' && piece.row === 1))) {
                    return !pieces.find(p => p.row === piece.row + dir && p.col === piece.col);
                }
            }
            if (Math.abs(dc) === 1 && dr === dir && targetPiece) return true;
            return false;
        case PIECES.ROOK:
            if (dr !== 0 && dc !== 0) return false;
            return isPathClear(piece.row, piece.col, targetR, targetC);
        case PIECES.BISHOP:
            if (Math.abs(dr) !== Math.abs(dc)) return false;
            return isPathClear(piece.row, piece.col, targetR, targetC);
        case PIECES.KNIGHT:
            return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2);
        case PIECES.QUEEN:
            if (dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) return false;
            return isPathClear(piece.row, piece.col, targetR, targetC);
        case PIECES.KING:
            return Math.abs(dr) <= 1 && Math.abs(dc) <= 1;
    }
    return true;
}

function isPathClear(r1, c1, r2, c2) {
    const dr = Math.sign(r2 - r1);
    const dc = Math.sign(c2 - c1);
    let currR = r1 + dr;
    let currC = c1 + dc;
    while (currR !== r2 || currC !== c2) {
        if (pieces.find(p => p.row === currR && p.col === currC)) return false;
        currR += dr;
        currC += dc;
    }
    return true;
}

function movePiece(piece, r, c) {
    const targetPiece = pieces.find(p => p.row === r && p.col === c);
    if (targetPiece) {
        showMessage(`‡∏´‡∏°‡∏≤‡∏Å‡∏Å‡∏¥‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!`);
        scene.remove(targetPiece.mesh);
        pieces = pieces.filter(p => p !== targetPiece);
    }
    gameState[piece.row][piece.col] = 0;
    piece.row = r;
    piece.col = c;
    gameState[r][c] = piece.color === 'white' ? piece.type : -piece.type;
    piece.mesh.position.set(c - 3.5, 0, r - 3.5);
    currentTurn = currentTurn === 'white' ? 'black' : 'white';
    updateUI();
}

function updateUI() {
    const indicator = document.getElementById('turn-indicator');
    indicator.innerText = `‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á: ‡∏™‡∏µ${currentTurn === 'white' ? '‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô' : '‡πÄ‡∏ó‡∏≤‡∏î‡∏≥'}`;
    indicator.style.color = currentTurn === 'white' ? '#2563eb' : '#1f2937';
}

function showMessage(msg) {
    const box = document.getElementById('message-box');
    box.innerText = msg;
    box.style.display = 'block';
    setTimeout(() => { box.style.display = 'none'; }, 1500);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    adjustCamera();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    moveHighlights.forEach(h => { h.rotation.z += 0.05; });
    renderer.render(scene, camera);
}
</script>
</body>
</html>
